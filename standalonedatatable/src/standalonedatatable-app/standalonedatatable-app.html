<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/bwt-datatable/bwt-datatable.html">
<link rel="import" href="../../bower_components/paper-card/paper-card.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">

<dom-module id="standalonedatatable-app">
  <template>
    <style>
      :host {
        display: block;
      }
      #tabl
      {
        width: 50%;
        float:left;
      }
      #modifcard{
        width:50%;
        float:right;
      }
    </style>
    <!-- appels au backend-->
    <!-- appel api récupération des notes -->
    <iron-ajax       
                
      id="fetchnotes"
      url="http://127.0.0.1:3000/notes/"
      method="GET"
      handle-as="json"
      on-response="_handleResponse"
      on-error="_error"></iron-ajax>
    <!-- appel api ajout à la database -->
    <!-- TODO: plancher sur l'ajout d'élément  -->
    <iron-ajax                
      id="createnotes"
      url="http://127.0.0.1:3000/notes/"
      method="POST"
      body="{{displayedItem}}" 
      handle-as="json"
      on-error="_error"></iron-ajax>
    <h2>Selection Changed? :[[propSelectionChanged]]!</h2> <!-- juste un test pour voir si le selection changed fonctionne bien-->

  <!-- Le tableau avec les notes-->
  <div id="tabl">
    <paper-datatable ref="itemList" id="tableau" data="{{datatab}}" selectable selected-item="{{selectedItem}}" >
      <paper-datatable-column header="Title" property="title" style="width:20%;"  sortable></paper-datatable-column>
      <paper-datatable-column header="Content" property="content" type="string" style="width:99%;height:99%;"  sortable></paper-datatable-column>
    </paper-datatable>
  </div>
  <!-- La datacard qui permet normalement de faire les modif, ne pas oublier de bien binder dans les deux sens avec {} -->
  <!-- Le type date s'ecrit au format yyyy-mm-dd  -->
  <div id="modifcard">
    <paper-card style="min-width:300px;margin:10px;" heading="Selected item">
      <div style="padding:0px 16px 16px 16px">
       <!-- <paper-input value="{{displayedItem.id}}" label="ID"></paper-input> -->
        <paper-input value="{{displayedItem.title}}" label="Title"></paper-input>
        <paper-input value="{{displayedItem.content}}" label="Content"></paper-input>
      </div>
    </paper-card>
    <h3>[[propError]]</h3>

  </div>
  <div id="buttons">
    <paper-button  on-click="_displayBlank">New</paper-button>
    <!-- Sert à set l'element dans la card à un élément vide -->
    <paper-button  on-click="_saveNewData">Save</paper-button>
    <!-- Sert à savegarder les données contenues dans la Card (appel à l'API) -->
    <paper-button  on-click="_reloadTable">Reload table</paper-button>
    <!-- Sert à charger les données depuis le backend -->
    <paper-button  on-click="_loadData">Load Data</paper-button>
  </div>

  </template>

  <script>
    /**
     * @customElement
     * @polymer
     */
             
    class StandalonedatatableApp extends Polymer.Element {

      
      static get is() { return 'standalonedatatable-app'; }
      static get properties() {
        return {
          propSelectionChanged: {
            type: String
          },
          propError: {
            type: String,
            value:""
          },
          //les datas de base en cas de non-chargement 
          datatab:{
            type:Array,
            value:[{title:"T'as un soucis, t'as pas de data", content: "nothing to see here, no data loaded yet"}
                    ]
          },
          //distinction entre l'objet affiché, l'objet selectionné, et les datatab recup depuis le backend et celle affichée (+ de flexibilité future)
          //object selectionné par l'utilisateur dans la table
          selectedItem:{
            type:Object,
            observer:'_selectionChanged',
            value:{}
          },
          //objet affiché dans la card de droite
          displayedItem:{
            type:Object,
            value:[{title:"",content:""}]
          },
          //array qui contiendra les données récupérées du backend
          ajaxdatatab:{
            type:Array
          }
        };
      }
      _selectionChanged(newValue, oldValue) // juste pour voir si ca se trigger bien
      {
          this.propSelectionChanged="Selection Changed";
          this.displayedItem=this.selectedItem;

      }
      _loadData() //sert à charger les notes
      {
        this.$.fetchnotes.generateRequest();
      }
      _saveNewData() //sert à charger les notes
      {
        this.$.createnotes.generateRequest();
      }
      _handleResponse(event) //appelé quand le json est chargé
      {
        // faire bien attention à la propriété à aller rechercher (difference avec le codelabs, pas de .dat sur la response)
        this.ajaxdatatab=event.detail.response;
        this.datatab=this.ajaxdatatab;
      }
       
      _error(event) //fonction appelée en cas d'erreur dans l'appel de l' API (voir les iron-ajax)
      {
        this.propError="Hum, ya un problème doc";
      }
      _displayBlank(event){
        this.displayedItem=[{title:"",content:""}];
        //selection du tableau qui contient les datas et appel de sa fonction de désélection générale
        var x=this.shadowRoot.querySelector("#tableau");
        console.log(x);
        x.deselectAll();
      }
      _displaySave(event)
      {
        //TODO: faire un appel au backend via l'API pour sauvegarder un nouvel élément
        //penser à recharger la liste des notes
        
      }
      _reloadTable(event){
        var x=this.shadowRoot.querySelector("#tableau");
        console.log(x);
        x.reload();
      }
    }

    window.customElements.define(StandalonedatatableApp.is, StandalonedatatableApp);
  </script>
</dom-module>
